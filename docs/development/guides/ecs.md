# Entity Components Systems (ECS)

Добро пожаловать в руководство по ECS. Данное руководство рассчитано на новичков и содержит лишь азы необходимые для работы.
Предполагается, что вы уже освоили клонирование репозитория, компилирование сборки и базовый прототипинг.

Здесь не будет речи и рассказов конкретно об архитектуре, а лишь руководство по работе с ней.

## Введение

Само название архитектуры кратко описывает суть всего происходящего в игре.

В первую очередь у нас есть `Entity` - это сущность, которой присвоен какой-либо идентификатор не равный нулю.
Это абсолютно любой объект в игре, стол, стул, грид, дверь, стена и так далее.

У нас есть `Components` - компоненты, наличие или отсутствие или различные параметры компонента дают различные свойства нашему `Entity`.
Например, есть компонент `PointLightComponent` - он превращает нашу сущность в лампу, заставляет её светится. В данном компоненте есть такие параметры как
`Energy` и `Radius`. `Energy` - количество энергии излучаемой `Entity`, чем это значение больше - тем ярче свет, `Radius` - радиус в тайлах в котором наш источник света светит, чем больше - тем более рассенным является `Energy` и если вы хотите сохранять прежнюю яркость при большем радиусе, то вам потребуется увеличить `Energy`. Стоит понимать, что сами по себе компоненты - не более чем контейнеры для данных, сами по себе они не имеют никакой логики, а чтобы наша лампа научилась светится для неё требуется собственная система освещения.

`EntitySystem` - система, дающая логику компонентам. Сами по себе системы тоже не существуют, системы описывают исключительно **логику** и **не имеют никаких данных**. Также системы могут **зависеть** друг от друга, когда логика некоторых компонентов соприкасается и может изменяться от появления другого компонента.

Зарезюмируем, у нас есть объект - `Entity`, со свойствами описанными компонентами `Components`, которые воплощаются в жизнь посредством систем `EntitySystems`.

Что представляют собой прототипы? Прототипы, по своей сути, это просто конфигурационные файлы, содержащие параметры для компонентов. Важно осознать, что это не инструмент для программирования логики, а лишь инструмент конфигурации.

## Основы

Весь контент в нашей кодовой базе разбит на 3 ключевых части:<br>
- `Content.Server`<br>
- `Content.Client`<br>
- `Content.Shared`

`Content.Server` - это код, выполняющийся исключительно на стороне сервера, компоненты и системы созданные здесь недоступны со стороны клиента, недоступны из `Content.Client`.

`Content.Client` - это код, выполняющийся исключительно на стороне клиента, так как компоненты и системы созданные в `Content.Server` нам здесь недоступны, то действительно и обратное - сервер не может получить доступа к системам и компонентам клиента, да и технически это сомнительно, поскольку сервер один, а клиентов много (каждый игрок - это отдельный клиент).

`Content.Shared` - в свою очередь, это код, описывающий системы и компоненты доступные И со стороны сервера (`Content.Server`) И со стороны клиента (`Content.Client`). Например, здесь могут описываться структуры сетевых сообщений, посредством которых `Content.Server` и `Content.Client` обмениваются данными друг с другом. Также, код здесь может требоваться для механизма предсказания со стороны клиента (`Predictions`), но это отдельная сложная тема, которую я опишу уже в полном руководстве по Networking. 

## Events: они же события

`Events` (события) - это отдельный вид сообщений, работу с которыми полностью выполняет движок, оставляя нам простое API. `Event` позволяет нам по какому-либо событию выполнить какую-либо операцию, в контексте `RobustToolbox` большинство событий крепится на сущностях и их компонентах. Например, если предмет в активной руке был активирован, то на сущности всплывает `Event` под названием `UseInHandEvent`, **подписавшись** на данное событие посредством компонента, мы сможем выполнить какую-либо операцию.

Подписаться на события можно двумя разными способами: компонентом и глобально. Но у событий есть одно ограничение - подписаться на него можно лишь 1 раз при помощи 1 компонента. Глобально подписаться можно лишь 1 раз. Если коротко, то при подписывании на событие через компонент, то логика в нашей системе будет выполняться только когда событие было вызванно на сущность, имеющую какой-либо компонент, если нужного компонента нет, то наша система пропустит его. При подписке на событие глобально, независимо от того, на какой сущности событие было вызвано - мы всегда на него отреагируем. Обычно, вам никогда не понадобится глобально подписываться на событие, кроме редких исключений, использовать их без необходимости - плохо и неправильно, но помнить о такой технической возможности стоит.

## На практике

Перейдём к практике на C#. Мы рассчитываем, что у вас уже есть репозиторий готовый для работы, в ином случае обратитесь к руководству по запуску локального сервера посредством компиляции сборки.

Разработаем следующий предмет - блюспейс-джаунтер, это предмет из Space Station 13, он выдаётся шахтёрам (утилизаторам) для того, чтобы из любой локации они могли легко переместится на случайную точку на станции. Применение простое, вы покидаете станцию, активируете джаунтер в активной руке - и вас телепортирует на случайную точку на станции. Обойдёмся без каких-либо эффектов для простоты руководства.

### Шаг 1. Компонент

Вы ведь внимательно читали [Введение](#_1)? Чтобы наша сущность (`Entity`) получила свойство телепортировать в случайную точку на станции, нам нужно дать ему компонент. Так как логику пишем мы, то этот компонент создать должны мы.

В первую очередь давайте по-рассуждаем, а где должен быть компонент? У клиента? У сервера? Или он нужен им обоим? Можно подумать, "если клиенту нужно активировать предмет в своей руке, то, должно быть, он должен быть доступен клиенту", но это неверно. Так как вычисления должны происходить на стороне сервера (конечно, вам никто не мешает выполнить телепортацию на стороне клиента, только сервер не признает такую операцию и реальное положение персонажа останется там же, где он был, стоит понимать - у клиента есть власть только над **отображением** данных), то и располагаться компонент должен на сервере, а клиенту он не требуется, поскольку активация предметов происходит при помощи системы `InteractionSystem`, которая самостоятельно пробрасывает **событие** действия клиента на сервер.

Создадим для работы над данной задачей отдельную папку: `Content.Server/_Exodus/BluespaceJaunter`, создадим файл `BluespaceJaunterComponent.cs` с следующим содержимым:
```cs
namespace Content.Server.Exodus.BluespaceJaunter;

[RegisterComponent]
public sealed partial class BluespaceJaunterComponent : Component
{
}
```

Здесь всё просто, мы создаём класс `BluespaceJaunterComponent` который должен наследоваться от класса `Component` для добавления логики компонента, а после добавляем к нему аннотацию `RegisterComponent`, чтобы движок зарегистрировал его и он работал как надо. Какие-либо данные нам здесь не требуются, но вот пример того, как эти данные добавить:
```cs
namespace Content.Server.Exodus.BluespaceJaunter;

[RegisterComponent]
public sealed partial class BluespaceJaunterComponent : Component
{
    [DataField] public float TeleportDelay = 2.0f;
}
```
По сути дела, вы просто добавляете свойство, к которому добавляется аннотация `DataField`. Данная аннотация, очевидно, нужна для того, чтобы игровой движок узнал о существовании нашего поля. Стоит знать, что для работы с этим полем нам, как разработчикам, эта аннотация не требуется, но показав это поле движку движок предоставляет вам:

- Во первых, возможность изменять свойство компонента посредством прототипа
```yaml
- type: entity
  id: SomeEntity
  components:
  - type: BluespaceJaunter
    teleportDelay: 4.0
```
Как вы могли заметить, окончание "Component" автоматически убирается, а название свойства указывается с нижнего регистра, если вы хотите, чтобы в коде свойство называлось одним образом, а в прототипе другим, то вы можете передать в аннотацию `DataField` название: `[DataField("delay")]` и тогда заместо "`teleportDelay`" в прототипе вам потребуется писать "`delay`". Вы также можете сделать это поле **обязательным** для указания в прототипе, если в прототипе это поле указано не будет, то движок создаст ошибку и данная сущность зарегистрирована не будет. Делается это посредством: `[DataField(required: true)]`, при комбинировании с названием: `[DataField("delay", required: true)]`.
- Во вторых, инструменты для синхронизации данных, если этот компонент является сетевым. Здесь я подробно этот момент описывать не буду, а в отдельном руководстве, которое появится в будущем, описывающим работу с сетями (как только это станет актуально, я отредактирую текущее руководство и прикреплю ссылку).

### Шаг 2. Система

Когда мы создали компонент, нам остаётся дать ему логику.

```cs
namespace Content.Server.Exodus.BluespaceJaunter;

public sealed partial class BluespaceJaunterSystem : EntitySystem
{
    [Dependency] private readonly TransformSystem _transform = default!;

    public override void Initialize()
    {
        SubscribeLocalEvent<BluespaceJaunterComponent, UseInHandEvent>(OnUseInHand);
    }

    private void OnUseInHand(Entity<BluespaceJaunterComponent> entity, ref UseInHandEvent ev)
    {
        // ...
    }
}
```

Во первых, для работы `EntitySystem` нам не требуется никаких аннотаций, любой класс, который наследуется от `EntitySystem` и не имеющий модификатора `abstract` уже является пригодным к работе.

У `EntitySystem` есть собственные методы жизненного цикла, один из которых вы можете увидеть в коде - `void Initialize()`.<br>
- `void Initialize()` - вызывается при запуске игры, здесь обычно система подписывается на события<br>
- `void Update(float frameTime)` - вызывается каждый тик игры, количество тиков в секунду строго ограничено и определяется сервером<br>
- `void FrameUpdate(float frameTime)` - хоть и можно определить на сервере, используется только на клиенте каждый кадр, который отрисовывается. Если здесь будет слишком много вычислений, то это напрямую скажется на количестве отрисовываемых кадров<br>
- `void Shutdown()` - вызывается при закрытии игры/выключении сервера (вызывается не всегда, т. к. процесс игры могут убить системными командами, которые не дадут вообще никакого времени на подобные методы)

Также одна система может зависеть от другой, при необходимости выполнять какие-либо операции связанные с другими компонентами не вмешиваясь напрямую в их данные, чтобы не ломать логику связанных систем. Делается это посредством аннотации `[Dependency]`, `= default!` нам нужно для обмана компилятора, чтобы у нас не возникало никаких проблем при работе с данной зависимостью. Во первых, стоит понимать, что шаг инъекции зависимостей производится ПОСЛЕ конструкции класса, если вы сделаете что-то вроде:

```cs
public sealed partial class BluespaceJaunterSystem : EntitySystem
{
    [Dependency] private readonly TransformSystem _transform = default!;

    public BluespaceJaunterSystem()
    {
        _transform.SomeMethod();
    }
}
```

То вы получите ошибку, говорящую о том, что `_transform` равен `null`. Но в методе `void Initialize` эти зависимости уже есть и там вы уже можете обращаться к ним без каких-либо проблем.

Подписывание на события происходит посредством метода `SubscribeLocalEvent<Component, Event>(Handler)`, где `Handler` - приватный метод текущей системы.

Также у нас есть ряд методов, используемых для оперирования компонентами:<br>
- `Component GetComp<Component>(EntityUid)` - возвращает указанный компонент, при отсутствии компонента выкинет не критическую ошибку, но неприятную, последствий много и заместо большой стены объяснений проще сказать, что этот метод не следует использовать без абсолютной уверенности в наличии нужного компонента.<br>
- `Component AddComp<Component>(EntityUid)` - добавляет сущности указанный компонент и возвращает его экземпляр для дальнейшей работы<br>
- `bool TryGetComp<Component>(EntityUid, out var Component?)` - проверяет наличие компонента, если компонент отсутствует, то вернёт значение `false`, а компонент в конструкции `out var` будет равен `null`, если компонент имеется, то вернёт значение `true`, а в `out var` сам компонент. Также следует отметить о наличии метки для компилятора, которая выполняет проверку на `null` и заместо сравнений с `null` вы можете проверить только значение `bool`, которое вернул метод. Если коротко, то применяется он так:
```cs
if (!TryComp<Component>(uid, out var component))
{
    // мы получили false
    // здесь component == null
    return; // прерываем выполнение
}
component.property; // НЕ null, поскольку компилятор понимает, что если бы компонент был null, то до сюда поток выполнения не дошёл
```

Перейдём к непосредственно нашему заданию - блюспейс-джаунтер.
Нам нужно сначала получить текущий грид станции, обратимся для этого к системе станции:

```cs
namespace Content.Server.Exodus.BluespaceJaunter;

public sealed partial class BluespaceJaunterSystem : EntitySystem
{
    [Dependency] private readonly StationSystem _station = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    [Dependency] private readonly MapSystem _map = default!;
    [Dependency] private readonly TransformSystem _transform = default!;

    public override void Initialize()
    {
        SubscribeLocalEvent<BluespaceJaunterComponent, UseInHandEvent>(OnUseInHand);
    }

    private void OnUseInHand(Entity<BluespaceJaunterComponent> entity, ref UseInHandEvent ev)
    {
        // если мы не смогли получить станцию - прерываем выполнение, нам некуда телепортироваться
        if (!TryGetStation(entity, out var station))
            return;

        // получаем случайный тайл для телепортации
        var tile = GetRandomTile(station);

        // непосредственная телепортация
        _transform.SetCoordinates(ev.User, new EntityCoordinates(station, tile.GridIndices));
    }

    // логика получения станции декомпозирована в отдельный метод на случай необходимости в большем количестве логики
    private bool TryGetStation(Entity<BluespaceJaunterComponent> entity, [NotNullWhen(true)] out Entity<MapGridComponent>? station)
    {
        grid = null;

        var stations = _station.GetStations();

        // Обычно, у нас невозможна ситуация, когда блюспейс-джаунтер будет активирован без станции,
        // но мы должны обработать такую ситуацию, если она предусмотрена технически, чтобы не произошло критических ошибок
        if (stations.Count == 0) 
            return false;

        // технически у нас предусмотрена возможность наличия множества станций, но геймплейно - нет, у нас нет в условии задания уточнений про множество станций, так что просто возьмём самую первую из списка
        var stationUid = stations.First();

        if (!TryComp<MapGridComponent>(stationUid, out var grid))
            return false;

        station = (stationUid, grid); // кортеж вида (EntityUid, Component) может неявно преобразовываться в Entity<Component>
        return true;
    }

    private TileRef GetRandomTile(Entity<MapGridComponent> grid)
    {
        var tiles = _map.GetAllTiles(grid, grid.Comp);
        return _random.Pick(tiles.ToList());
    }
}
```

Система готова!

### Шаг 3. Прототип

Не могло же всё закончиться? Пора вернуться к истокам, к прототипам! Прототипы - это, по своей сути, конфигурационные файлы для компонентов.
```yaml
- type: entity
  id: BluespaceJaunter
  name: bluespace jaunter
  description: A device that uses experimental bluespace technology to teleport the user to a random location on the station.
  components:
  - type: Item
  - type: Sprite
    sprite: Objects/Tools/jumper.rsi
    state: icon
  - type: BluespaceJaunter
```
Все остальные свойства вы можете выбрать на своё усмотрение.

## Итоги

В данном руководстве мы рассмотрели основы работы с ECS в кодовой базе Space Station 14.
Помните о том, что вы должны всегда использовать существующие системы, если вам нужно что-либо сделать со сторонним компонентом.
Перед тем, как реализовывать какой-либо метод проверяйте, не реализован ли он уже в какой-то другой системе.

Далее вам следует освоить сетевой обмен и синхронизацию данных, но пока такого руководства нет, практикуйтесь и не стесняйтесь задавать вопросы более опытным разработчикам!
